<!DOCTYPE html>
<html>

<body>
    <canvas id="myCanvas" width="400" height="400" style="border:1px solid #c3c3c3;">
        Your browser does not support the HTML5 canvas tag.
    </canvas>
    <script type="text/javascript">
    var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");
    var canvasWidth = 400;
    var canvasHeight = 400;
    var moveSpeed = 300;
    var gridSize = 10;
    var size = 10;
    var Direction = {};
    Direction.up = 0;
    Direction.down = 1;
    Direction.left = 2;
    Direction.right = 3;
    Direction.none = 4;
    var headX = 200;
    var headY = 200;
    var moveTimer;
    var directionPrevious = Direction.none;
    var direction = Direction.right; // Under initial codition,it won't move

    // ctx.fillStyle = "red";
    // ctx.font = "bold 26px"; //字体样式
    // ctx.textAlign = "statr"; //对齐方式为左对齐
    // ctx.textBaseline = "top"; //基线
    // ctx.fillText("你好", 400, 400, 200);

    intital(); //初始化
    start();
    var score=0;
    drawDot(500,500,"blue");

    function intital()
    {
        document.onkeydown = onkeydown;
    }

    function start()
    {
        ctx.fillStyle = "grey";
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        snakeBody = new Array();

        for (var i = 0; i < size; i++)
        {
            snakeBody[i] = new Array();
            snakeBody[i][0] = headX - i * gridSize;
            snakeBody[i][1] = headY;
            drawDot(snakeBody[i][0], snakeBody[i][1], "black");
        }
        drawDot(snakeBody[0][0],snakeBody[0][1],"blue") //初始化将蛇头画蓝，蛇身画黑
        spawnFood();
    }

    function onTick()
    {
        if (isDead())
        {
            gameOver();
            return;
        }

        if (IsReverseInput())
        {
            direction = directionPrevious; //判断当按下按键，若蛇朝该方向走会踩到蛇身时，不让它朝此方向走，而继续按照原来的方向走
        }

        var lastBody = rememberLastBody(snakeBody);

        move(direction);

        if (hasAteFood())
        {
            // snakeBody  add 1
            addBody(snakeBody, lastBody);
            score++;    //吃到食物后分数加1
            //spawn food again
            spawnFood();
        }
    }




    function addBody(body, lastBd)
    {
        body[body.length] = new Array(lastBd.lastBodyX, lastBd.lastBodyY);
        // body[body.length] = lastBd;     引用传递

        drawDot(body[body.length - 1][0], body[body.length - 1][1], "black");

    }

    function hasAteFood()
    {
        return (snakeBody[0][0] == foodX) && (snakeBody[0][1] == foodY);

    }

    var hasSetInternal = false;

    function onkeydown()
    {
        key = event.keyCode;
        console.log(key);
        if (!hasSetInternal) //第一次按下任意键生成定时器，且只会生成一个定时器，后面再按不再生成新的定时器
        {
            moveTimer = setInterval("onTick()", moveSpeed);
            direction = Direction.right; //第一次按下任意键都向右走，后面根据按键正常上下左右走
            hasSetInternal = true;
            return;
        }

        switch (key)
        {
            case 65: //left
                direction = Direction.left;
                break;
            case 87: //up
                direction = Direction.up;
                break;
            case 68: //right
                direction = Direction.right;
                break;
            case 83: //down
                direction = Direction.down;
                break;
        }
    }


    function move(movDir)
    {
        drawDot(snakeBody[snakeBody.length - 1][0], snakeBody[snakeBody.length - 1][1], "grey");

        var newHeadX = snakeBody[0][0];
        var newHeadY = snakeBody[0][1];

        for (var i = snakeBody.length - 1; i >= 1; i--) //值传递
        {
            snakeBody[i][0] = snakeBody[i - 1][0];
            snakeBody[i][1] = snakeBody[i - 1][1];
            drawDot(snakeBody[1][0],snakeBody[1][1],"black");  //保证蛇身前进仍然是黑色
        }

        switch (movDir)
        {
            case Direction.left:
                newHeadX = newHeadX - 1 * gridSize;
                break;
            case Direction.up:
                newHeadY = newHeadY - 1 * gridSize;
                break;
            case Direction.right:
                newHeadX = newHeadX + 1 * gridSize;
                break;
            case Direction.down:
                newHeadY = newHeadY + 1 * gridSize;
                break;
        }

        snakeBody[0][0] = newHeadX;
        snakeBody[0][1] = newHeadY;
        drawDot(snakeBody[0][0], snakeBody[0][1], "blue");  //新的蛇头画蓝

        directionPrevious = movDir;
    }

    function rememberLastBody(body)
    {
        // var l = new Array();        
        // l[0] = body[body.length - 1][0];
        // l[1] = body[body.length - 1][1];
        // return l;
        return {
            lastBodyX: body[body.length - 1][0],
            lastBodyY: body[body.length - 1][1]
        };

    }

    function drawDot(x, y, color)
    {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, gridSize, gridSize);
    }

    var foodX, foodY;
    //生成随机食物,判断食物是否压到身子，压到则重新生成
    function spawnFood()
    {
        var lengthX = canvasWidth / gridSize;
        var lengthY = canvasHeight / gridSize;
        var isSuccess = false;
        while (!isSuccess)
        {
            foodX = parseInt(Math.random() * lengthX) * gridSize;
            foodY = parseInt(Math.random() * lengthY) * gridSize;
            isSuccess = true;
            for (var i = 0; i < snakeBody.length; i++)
            {
                if ((foodX == snakeBody[i][0]) && (foodY == snakeBody[i][1]))
                {
                    isSuccess = false;
                }
            }
        }

        drawDot(foodX, foodY, "red");
    }

    function IsReverseInput() //判断是否需要反向走才能正常继续
    {
        var newHeadX = snakeBody[0][0];
        var newHeadY = snakeBody[0][1];
        switch (direction)
        {
            case Direction.left:
                newHeadX = newHeadX - 1 * gridSize;
                break;
            case Direction.up:
                newHeadY = newHeadY - 1 * gridSize;
                break;
            case Direction.right:
                newHeadX = newHeadX + 1 * gridSize;
                break;
            case Direction.down:
                newHeadY = newHeadY + 1 * gridSize;
                break;
        }
        return (newHeadX == snakeBody[1][0] && newHeadY == snakeBody[1][1]);
    }


    function isDead()
    {
        return (hasTouchedWall() || headTouchedBody())
    }

    function gameOver() //游戏结束后关闭定时器重新开始重新开启定时器
    {
        alert("Game over,your final score is:"+score);
        score=0;     //游戏结束后分数清零
        clearInterval(moveTimer);
        start();
        hasSetInternal = false;
    }

    function hasTouchedWall() //判断是否撞墙，可以贴墙走，不能撞墙
    {
        var touchedWall = false;
        var newHeadX = snakeBody[0][0];
        var newHeadY = snakeBody[0][1];
        switch (direction)
        {
            case Direction.left:
                newHeadX = newHeadX - 1 * gridSize;
                break;
            case Direction.up:
                newHeadY = newHeadY - 1 * gridSize;
                break;
            case Direction.right:
                newHeadX = newHeadX + 1 * gridSize;
                break;
            case Direction.down:
                newHeadY = newHeadY + 1 * gridSize;
                break;
        }

        if (
            newHeadX < 0 ||
            newHeadY < 0 ||
            (newHeadX > canvasWidth - gridSize) ||
            (newHeadY > canvasHeight - gridSize)
        )
        {
            touchedWall = true;
        }
        return touchedWall;
    }

    function headTouchedBody()
    {
        var touchedBody = false;
        var newHeadX = snakeBody[0][0];
        var newHeadY = snakeBody[0][1];
        switch (direction)
        {
            case Direction.left:
                newHeadX = newHeadX - 1 * gridSize;
                break;
            case Direction.up:
                newHeadY = newHeadY - 1 * gridSize;
                break;
            case Direction.right:
                newHeadX = newHeadX + 1 * gridSize;
                break;
            case Direction.down:
                newHeadY = newHeadY + 1 * gridSize;
                break;
        }
        for (var i = 2; i < snakeBody.length; i++)
        {
            if ((newHeadX == snakeBody[i][0]) && (newHeadY == snakeBody[i][1]))
            {
                touchedBody = true;
                break;
            }
        }
        return touchedBody;
    }
    </script>
</body>

</html>